"""
Vulnerability registry module — /api/v1/vulnerabilities
"""
from datetime import date

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_session
from app.models.vulnerability import VulnerabilityRecord
from app.models.asset import Asset
from app.models.dictionary import DictionaryEntry
from app.models.org_unit import OrgUnit
from app.schemas.vulnerability import (
    VulnerabilityCreate,
    VulnerabilityMetrics,
    VulnerabilityOut,
    VulnerabilityStatusChange,
    VulnerabilityUpdate,
)

router = APIRouter(prefix="/api/v1/vulnerabilities", tags=["Rejestr podatności"])


# ── helper ──

async def _de_label(s: AsyncSession, entry_id: int | None) -> str | None:
    if entry_id is None:
        return None
    e = await s.get(DictionaryEntry, entry_id)
    return e.label if e else None


async def _vuln_out(s: AsyncSession, v: VulnerabilityRecord) -> VulnerabilityOut:
    org = await s.get(OrgUnit, v.org_unit_id) if v.org_unit_id else None
    asset = await s.get(Asset, v.asset_id) if v.asset_id else None
    return VulnerabilityOut(
        id=v.id,
        ref_id=v.ref_id,
        title=v.title,
        description=v.description,
        source_id=v.source_id,
        source_name=await _de_label(s, v.source_id),
        org_unit_id=v.org_unit_id,
        org_unit_name=org.name if org else None,
        asset_id=v.asset_id,
        asset_name=asset.name if asset else None,
        category_id=v.category_id,
        category_name=await _de_label(s, v.category_id),
        severity_id=v.severity_id,
        severity_name=await _de_label(s, v.severity_id),
        cvss_score=float(v.cvss_score) if v.cvss_score is not None else None,
        cvss_vector=v.cvss_vector,
        cve_id=v.cve_id,
        status_id=v.status_id,
        status_name=await _de_label(s, v.status_id),
        remediation_priority_id=v.remediation_priority_id,
        remediation_priority_name=await _de_label(s, v.remediation_priority_id),
        owner=v.owner,
        detected_at=v.detected_at,
        closed_at=v.closed_at,
        sla_deadline=v.sla_deadline,
        remediation_notes=v.remediation_notes,
        risk_id=v.risk_id,
        created_by=v.created_by,
        is_active=v.is_active,
        created_at=v.created_at,
        updated_at=v.updated_at,
    )


async def _next_ref_id(s: AsyncSession) -> str:
    row = await s.execute(
        select(func.max(VulnerabilityRecord.id))
    )
    max_id = row.scalar() or 0
    return f"VULN-{max_id + 1:04d}"


# ═══════════════════ METRICS (before {id} to avoid path collision) ═══════════════

@router.get("/metrics", response_model=VulnerabilityMetrics, summary="Metryki podatności")
async def get_vulnerability_metrics(s: AsyncSession = Depends(get_session)):
    # Count open vulnerabilities (not closed, not accepted)
    open_q = (
        select(func.count())
        .select_from(VulnerabilityRecord)
        .where(VulnerabilityRecord.is_active.is_(True))
        .outerjoin(DictionaryEntry, DictionaryEntry.id == VulnerabilityRecord.status_id)
        .where(DictionaryEntry.code.notin_(["closed", "accepted"]))
    )
    total_open = (await s.execute(open_q)).scalar() or 0

    # By severity
    sev_q = (
        select(DictionaryEntry.label, func.count())
        .select_from(VulnerabilityRecord)
        .join(DictionaryEntry, DictionaryEntry.id == VulnerabilityRecord.severity_id)
        .where(VulnerabilityRecord.is_active.is_(True))
        .group_by(DictionaryEntry.label)
    )
    sev_rows = (await s.execute(sev_q)).all()
    by_severity = {label: count for label, count in sev_rows}

    # SLA compliance
    today = date.today()
    total_with_sla = (await s.execute(
        select(func.count())
        .select_from(VulnerabilityRecord)
        .where(VulnerabilityRecord.is_active.is_(True))
        .where(VulnerabilityRecord.sla_deadline.isnot(None))
    )).scalar() or 0

    within_sla = 0
    if total_with_sla > 0:
        within_sla = (await s.execute(
            select(func.count())
            .select_from(VulnerabilityRecord)
            .where(VulnerabilityRecord.is_active.is_(True))
            .where(VulnerabilityRecord.sla_deadline.isnot(None))
            .where(
                (VulnerabilityRecord.closed_at <= VulnerabilityRecord.sla_deadline)
                | (
                    VulnerabilityRecord.closed_at.is_(None)
                    & (VulnerabilityRecord.sla_deadline >= today)
                )
            )
        )).scalar() or 0

    sla_pct = (within_sla / total_with_sla * 100) if total_with_sla > 0 else None

    return VulnerabilityMetrics(
        total_open=total_open,
        by_severity=by_severity,
        sla_compliance_pct=round(sla_pct, 1) if sla_pct is not None else None,
    )


# ═══════════════════ LIST ═══════════════════

@router.get("", response_model=list[VulnerabilityOut], summary="Lista podatności")
async def list_vulnerabilities(
    org_unit_id: int | None = Query(None),
    asset_id: int | None = Query(None),
    severity_id: int | None = Query(None),
    status_id: int | None = Query(None),
    include_archived: bool = Query(False),
    s: AsyncSession = Depends(get_session),
):
    q = select(VulnerabilityRecord)
    if not include_archived:
        q = q.where(VulnerabilityRecord.is_active.is_(True))
    if org_unit_id is not None:
        q = q.where(VulnerabilityRecord.org_unit_id == org_unit_id)
    if asset_id is not None:
        q = q.where(VulnerabilityRecord.asset_id == asset_id)
    if severity_id is not None:
        q = q.where(VulnerabilityRecord.severity_id == severity_id)
    if status_id is not None:
        q = q.where(VulnerabilityRecord.status_id == status_id)
    q = q.order_by(VulnerabilityRecord.detected_at.desc())
    vulns = (await s.execute(q)).scalars().all()
    return [await _vuln_out(s, v) for v in vulns]


# ═══════════════════ GET ═══════════════════

@router.get("/{vuln_id}", response_model=VulnerabilityOut, summary="Szczegóły podatności")
async def get_vulnerability(vuln_id: int, s: AsyncSession = Depends(get_session)):
    v = await s.get(VulnerabilityRecord, vuln_id)
    if not v:
        raise HTTPException(404, "Podatność nie istnieje")
    return await _vuln_out(s, v)


# ═══════════════════ CREATE ═══════════════════

@router.post("", response_model=VulnerabilityOut, status_code=201, summary="Nowa podatność")
async def create_vulnerability(body: VulnerabilityCreate, s: AsyncSession = Depends(get_session)):
    v = VulnerabilityRecord(**body.model_dump())
    s.add(v)
    await s.flush()
    v.ref_id = f"VULN-{v.id:04d}"
    await s.commit()
    await s.refresh(v)
    return await _vuln_out(s, v)


# ═══════════════════ UPDATE ═══════════════════

@router.put("/{vuln_id}", response_model=VulnerabilityOut, summary="Edycja podatności")
async def update_vulnerability(
    vuln_id: int, body: VulnerabilityUpdate, s: AsyncSession = Depends(get_session),
):
    v = await s.get(VulnerabilityRecord, vuln_id)
    if not v:
        raise HTTPException(404, "Podatność nie istnieje")
    for k, val in body.model_dump(exclude_unset=True).items():
        setattr(v, k, val)
    await s.commit()
    await s.refresh(v)
    return await _vuln_out(s, v)


# ═══════════════════ STATUS CHANGE ═══════════════════

@router.patch("/{vuln_id}/status", response_model=VulnerabilityOut, summary="Zmiana statusu")
async def change_vulnerability_status(
    vuln_id: int, body: VulnerabilityStatusChange, s: AsyncSession = Depends(get_session),
):
    v = await s.get(VulnerabilityRecord, vuln_id)
    if not v:
        raise HTTPException(404, "Podatność nie istnieje")
    v.status_id = body.status_id
    if body.remediation_notes:
        v.remediation_notes = body.remediation_notes

    # Auto-set closed_at when status is "closed"
    status_entry = await s.get(DictionaryEntry, body.status_id)
    if status_entry and status_entry.code == "closed" and v.closed_at is None:
        v.closed_at = date.today()

    await s.commit()
    await s.refresh(v)
    return await _vuln_out(s, v)


# ═══════════════════ ARCHIVE ═══════════════════

@router.delete("/{vuln_id}", summary="Archiwizuj podatność")
async def archive_vulnerability(vuln_id: int, s: AsyncSession = Depends(get_session)):
    v = await s.get(VulnerabilityRecord, vuln_id)
    if not v:
        raise HTTPException(404, "Podatność nie istnieje")
    v.is_active = False
    await s.commit()
    return {"status": "archived", "id": vuln_id}
